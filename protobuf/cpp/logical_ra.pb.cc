// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "logical_ra.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* LogicalRaQueryMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogicalRaQueryMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogicalRaOperator_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogicalRaOperator_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* LogicalRaOperator_LogicalRaOperatorType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* LogicalScan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogicalScan_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogicalSelect_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogicalSelect_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogicalProject_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogicalProject_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogicalEquiJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogicalEquiJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogicalCross_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogicalCross_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_logical_5fra_2eproto() {
  protobuf_AddDesc_logical_5fra_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "logical_ra.proto");
  GOOGLE_CHECK(file != NULL);
  LogicalRaQueryMessage_descriptor_ = file->message_type(0);
  static const int LogicalRaQueryMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaQueryMessage, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaQueryMessage, operators_),
  };
  LogicalRaQueryMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogicalRaQueryMessage_descriptor_,
      LogicalRaQueryMessage::default_instance_,
      LogicalRaQueryMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaQueryMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaQueryMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogicalRaQueryMessage));
  LogicalRaOperator_descriptor_ = file->message_type(1);
  static const int LogicalRaOperator_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaOperator, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaOperator, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaOperator, scan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaOperator, select_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaOperator, project_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaOperator, equijoin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaOperator, cross_),
  };
  LogicalRaOperator_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogicalRaOperator_descriptor_,
      LogicalRaOperator::default_instance_,
      LogicalRaOperator_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaOperator, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalRaOperator, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogicalRaOperator));
  LogicalRaOperator_LogicalRaOperatorType_descriptor_ = LogicalRaOperator_descriptor_->enum_type(0);
  LogicalScan_descriptor_ = file->message_type(2);
  static const int LogicalScan_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalScan, relation_),
  };
  LogicalScan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogicalScan_descriptor_,
      LogicalScan::default_instance_,
      LogicalScan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalScan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalScan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogicalScan));
  LogicalSelect_descriptor_ = file->message_type(3);
  static const int LogicalSelect_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalSelect, childname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalSelect, condition_),
  };
  LogicalSelect_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogicalSelect_descriptor_,
      LogicalSelect::default_instance_,
      LogicalSelect_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalSelect, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalSelect, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogicalSelect));
  LogicalProject_descriptor_ = file->message_type(4);
  static const int LogicalProject_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalProject, childname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalProject, columns_),
  };
  LogicalProject_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogicalProject_descriptor_,
      LogicalProject::default_instance_,
      LogicalProject_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalProject, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalProject, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogicalProject));
  LogicalEquiJoin_descriptor_ = file->message_type(5);
  static const int LogicalEquiJoin_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalEquiJoin, leftchildname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalEquiJoin, leftcolumns_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalEquiJoin, rightchildname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalEquiJoin, rightcolumns_),
  };
  LogicalEquiJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogicalEquiJoin_descriptor_,
      LogicalEquiJoin::default_instance_,
      LogicalEquiJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalEquiJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalEquiJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogicalEquiJoin));
  LogicalCross_descriptor_ = file->message_type(6);
  static const int LogicalCross_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalCross, leftchildname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalCross, rightchildname_),
  };
  LogicalCross_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogicalCross_descriptor_,
      LogicalCross::default_instance_,
      LogicalCross_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalCross, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalCross, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogicalCross));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_logical_5fra_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogicalRaQueryMessage_descriptor_, &LogicalRaQueryMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogicalRaOperator_descriptor_, &LogicalRaOperator::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogicalScan_descriptor_, &LogicalScan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogicalSelect_descriptor_, &LogicalSelect::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogicalProject_descriptor_, &LogicalProject::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogicalEquiJoin_descriptor_, &LogicalEquiJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogicalCross_descriptor_, &LogicalCross::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_logical_5fra_2eproto() {
  delete LogicalRaQueryMessage::default_instance_;
  delete LogicalRaQueryMessage_reflection_;
  delete LogicalRaOperator::default_instance_;
  delete LogicalRaOperator_reflection_;
  delete LogicalScan::default_instance_;
  delete LogicalScan_reflection_;
  delete LogicalSelect::default_instance_;
  delete LogicalSelect_reflection_;
  delete LogicalProject::default_instance_;
  delete LogicalProject_reflection_;
  delete LogicalEquiJoin::default_instance_;
  delete LogicalEquiJoin_reflection_;
  delete LogicalCross::default_instance_;
  delete LogicalCross_reflection_;
}

void protobuf_AddDesc_logical_5fra_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020logical_ra.proto\"L\n\025LogicalRaQueryMess"
    "age\022\014\n\004name\030\001 \002(\t\022%\n\toperators\030\003 \003(\0132\022.L"
    "ogicalRaOperator\"\330\002\n\021LogicalRaOperator\0226"
    "\n\004type\030\001 \002(\0162(.LogicalRaOperator.Logical"
    "RaOperatorType\022\014\n\004name\030\002 \002(\t\022\032\n\004scan\030\003 \001"
    "(\0132\014.LogicalScan\022\036\n\006select\030\004 \001(\0132\016.Logic"
    "alSelect\022 \n\007project\030\005 \001(\0132\017.LogicalProje"
    "ct\022\"\n\010equijoin\030\006 \001(\0132\020.LogicalEquiJoin\022\034"
    "\n\005cross\030\007 \001(\0132\r.LogicalCross\"]\n\025LogicalR"
    "aOperatorType\022\010\n\004SCAN\020\000\022\013\n\007PROJECT\020\001\022\010\n\004"
    "JOIN\020\002\022\n\n\006SELECT\020\003\022\014\n\010EQUIJOIN\020\004\022\t\n\005CROS"
    "S\020\005\"\037\n\013LogicalScan\022\020\n\010relation\030\001 \002(\t\"5\n\r"
    "LogicalSelect\022\021\n\tchildName\030\001 \002(\t\022\021\n\tcond"
    "ition\030\002 \002(\t\"4\n\016LogicalProject\022\021\n\tchildNa"
    "me\030\001 \002(\t\022\017\n\007columns\030\002 \003(\005\"k\n\017LogicalEqui"
    "Join\022\025\n\rleftChildName\030\001 \002(\t\022\023\n\013leftColum"
    "ns\030\002 \003(\005\022\026\n\016rightChildName\030\003 \002(\t\022\024\n\014righ"
    "tColumns\030\004 \003(\005\"=\n\014LogicalCross\022\025\n\rleftCh"
    "ildName\030\001 \002(\t\022\026\n\016rightChildName\030\002 \002(\tB6\n"
    "$edu.washington.escience.myriad.protoB\016L"
    "ogicalRaProto", 813);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "logical_ra.proto", &protobuf_RegisterTypes);
  LogicalRaQueryMessage::default_instance_ = new LogicalRaQueryMessage();
  LogicalRaOperator::default_instance_ = new LogicalRaOperator();
  LogicalScan::default_instance_ = new LogicalScan();
  LogicalSelect::default_instance_ = new LogicalSelect();
  LogicalProject::default_instance_ = new LogicalProject();
  LogicalEquiJoin::default_instance_ = new LogicalEquiJoin();
  LogicalCross::default_instance_ = new LogicalCross();
  LogicalRaQueryMessage::default_instance_->InitAsDefaultInstance();
  LogicalRaOperator::default_instance_->InitAsDefaultInstance();
  LogicalScan::default_instance_->InitAsDefaultInstance();
  LogicalSelect::default_instance_->InitAsDefaultInstance();
  LogicalProject::default_instance_->InitAsDefaultInstance();
  LogicalEquiJoin::default_instance_->InitAsDefaultInstance();
  LogicalCross::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_logical_5fra_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_logical_5fra_2eproto {
  StaticDescriptorInitializer_logical_5fra_2eproto() {
    protobuf_AddDesc_logical_5fra_2eproto();
  }
} static_descriptor_initializer_logical_5fra_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int LogicalRaQueryMessage::kNameFieldNumber;
const int LogicalRaQueryMessage::kOperatorsFieldNumber;
#endif  // !_MSC_VER

LogicalRaQueryMessage::LogicalRaQueryMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LogicalRaQueryMessage::InitAsDefaultInstance() {
}

LogicalRaQueryMessage::LogicalRaQueryMessage(const LogicalRaQueryMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LogicalRaQueryMessage::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogicalRaQueryMessage::~LogicalRaQueryMessage() {
  SharedDtor();
}

void LogicalRaQueryMessage::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void LogicalRaQueryMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogicalRaQueryMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogicalRaQueryMessage_descriptor_;
}

const LogicalRaQueryMessage& LogicalRaQueryMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logical_5fra_2eproto();  return *default_instance_;
}

LogicalRaQueryMessage* LogicalRaQueryMessage::default_instance_ = NULL;

LogicalRaQueryMessage* LogicalRaQueryMessage::New() const {
  return new LogicalRaQueryMessage;
}

void LogicalRaQueryMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  operators_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogicalRaQueryMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_operators;
        break;
      }
      
      // repeated .LogicalRaOperator operators = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operators:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_operators()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_operators;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogicalRaQueryMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // repeated .LogicalRaOperator operators = 3;
  for (int i = 0; i < this->operators_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->operators(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LogicalRaQueryMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // repeated .LogicalRaOperator operators = 3;
  for (int i = 0; i < this->operators_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->operators(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LogicalRaQueryMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  // repeated .LogicalRaOperator operators = 3;
  total_size += 1 * this->operators_size();
  for (int i = 0; i < this->operators_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->operators(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogicalRaQueryMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogicalRaQueryMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogicalRaQueryMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogicalRaQueryMessage::MergeFrom(const LogicalRaQueryMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  operators_.MergeFrom(from.operators_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogicalRaQueryMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicalRaQueryMessage::CopyFrom(const LogicalRaQueryMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalRaQueryMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < operators_size(); i++) {
    if (!this->operators(i).IsInitialized()) return false;
  }
  return true;
}

void LogicalRaQueryMessage::Swap(LogicalRaQueryMessage* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    operators_.Swap(&other->operators_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogicalRaQueryMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogicalRaQueryMessage_descriptor_;
  metadata.reflection = LogicalRaQueryMessage_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* LogicalRaOperator_LogicalRaOperatorType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogicalRaOperator_LogicalRaOperatorType_descriptor_;
}
bool LogicalRaOperator_LogicalRaOperatorType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const LogicalRaOperator_LogicalRaOperatorType LogicalRaOperator::SCAN;
const LogicalRaOperator_LogicalRaOperatorType LogicalRaOperator::PROJECT;
const LogicalRaOperator_LogicalRaOperatorType LogicalRaOperator::JOIN;
const LogicalRaOperator_LogicalRaOperatorType LogicalRaOperator::SELECT;
const LogicalRaOperator_LogicalRaOperatorType LogicalRaOperator::EQUIJOIN;
const LogicalRaOperator_LogicalRaOperatorType LogicalRaOperator::CROSS;
const LogicalRaOperator_LogicalRaOperatorType LogicalRaOperator::LogicalRaOperatorType_MIN;
const LogicalRaOperator_LogicalRaOperatorType LogicalRaOperator::LogicalRaOperatorType_MAX;
const int LogicalRaOperator::LogicalRaOperatorType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int LogicalRaOperator::kTypeFieldNumber;
const int LogicalRaOperator::kNameFieldNumber;
const int LogicalRaOperator::kScanFieldNumber;
const int LogicalRaOperator::kSelectFieldNumber;
const int LogicalRaOperator::kProjectFieldNumber;
const int LogicalRaOperator::kEquijoinFieldNumber;
const int LogicalRaOperator::kCrossFieldNumber;
#endif  // !_MSC_VER

LogicalRaOperator::LogicalRaOperator()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LogicalRaOperator::InitAsDefaultInstance() {
  scan_ = const_cast< ::LogicalScan*>(&::LogicalScan::default_instance());
  select_ = const_cast< ::LogicalSelect*>(&::LogicalSelect::default_instance());
  project_ = const_cast< ::LogicalProject*>(&::LogicalProject::default_instance());
  equijoin_ = const_cast< ::LogicalEquiJoin*>(&::LogicalEquiJoin::default_instance());
  cross_ = const_cast< ::LogicalCross*>(&::LogicalCross::default_instance());
}

LogicalRaOperator::LogicalRaOperator(const LogicalRaOperator& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LogicalRaOperator::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  scan_ = NULL;
  select_ = NULL;
  project_ = NULL;
  equijoin_ = NULL;
  cross_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogicalRaOperator::~LogicalRaOperator() {
  SharedDtor();
}

void LogicalRaOperator::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete scan_;
    delete select_;
    delete project_;
    delete equijoin_;
    delete cross_;
  }
}

void LogicalRaOperator::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogicalRaOperator::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogicalRaOperator_descriptor_;
}

const LogicalRaOperator& LogicalRaOperator::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logical_5fra_2eproto();  return *default_instance_;
}

LogicalRaOperator* LogicalRaOperator::default_instance_ = NULL;

LogicalRaOperator* LogicalRaOperator::New() const {
  return new LogicalRaOperator;
}

void LogicalRaOperator::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_scan()) {
      if (scan_ != NULL) scan_->::LogicalScan::Clear();
    }
    if (has_select()) {
      if (select_ != NULL) select_->::LogicalSelect::Clear();
    }
    if (has_project()) {
      if (project_ != NULL) project_->::LogicalProject::Clear();
    }
    if (has_equijoin()) {
      if (equijoin_ != NULL) equijoin_->::LogicalEquiJoin::Clear();
    }
    if (has_cross()) {
      if (cross_ != NULL) cross_->::LogicalCross::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogicalRaOperator::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .LogicalRaOperator.LogicalRaOperatorType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::LogicalRaOperator_LogicalRaOperatorType_IsValid(value)) {
            set_type(static_cast< ::LogicalRaOperator_LogicalRaOperatorType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_scan;
        break;
      }
      
      // optional .LogicalScan scan = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_scan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scan()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_select;
        break;
      }
      
      // optional .LogicalSelect select = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_select:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_select()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_project;
        break;
      }
      
      // optional .LogicalProject project = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_project:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_project()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_equijoin;
        break;
      }
      
      // optional .LogicalEquiJoin equijoin = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_equijoin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_equijoin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_cross;
        break;
      }
      
      // optional .LogicalCross cross = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cross:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cross()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogicalRaOperator::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .LogicalRaOperator.LogicalRaOperatorType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  // optional .LogicalScan scan = 3;
  if (has_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->scan(), output);
  }
  
  // optional .LogicalSelect select = 4;
  if (has_select()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->select(), output);
  }
  
  // optional .LogicalProject project = 5;
  if (has_project()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->project(), output);
  }
  
  // optional .LogicalEquiJoin equijoin = 6;
  if (has_equijoin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->equijoin(), output);
  }
  
  // optional .LogicalCross cross = 7;
  if (has_cross()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->cross(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LogicalRaOperator::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .LogicalRaOperator.LogicalRaOperatorType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }
  
  // optional .LogicalScan scan = 3;
  if (has_scan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->scan(), target);
  }
  
  // optional .LogicalSelect select = 4;
  if (has_select()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->select(), target);
  }
  
  // optional .LogicalProject project = 5;
  if (has_project()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->project(), target);
  }
  
  // optional .LogicalEquiJoin equijoin = 6;
  if (has_equijoin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->equijoin(), target);
  }
  
  // optional .LogicalCross cross = 7;
  if (has_cross()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->cross(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LogicalRaOperator::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .LogicalRaOperator.LogicalRaOperatorType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional .LogicalScan scan = 3;
    if (has_scan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->scan());
    }
    
    // optional .LogicalSelect select = 4;
    if (has_select()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->select());
    }
    
    // optional .LogicalProject project = 5;
    if (has_project()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->project());
    }
    
    // optional .LogicalEquiJoin equijoin = 6;
    if (has_equijoin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->equijoin());
    }
    
    // optional .LogicalCross cross = 7;
    if (has_cross()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cross());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogicalRaOperator::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogicalRaOperator* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogicalRaOperator*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogicalRaOperator::MergeFrom(const LogicalRaOperator& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_scan()) {
      mutable_scan()->::LogicalScan::MergeFrom(from.scan());
    }
    if (from.has_select()) {
      mutable_select()->::LogicalSelect::MergeFrom(from.select());
    }
    if (from.has_project()) {
      mutable_project()->::LogicalProject::MergeFrom(from.project());
    }
    if (from.has_equijoin()) {
      mutable_equijoin()->::LogicalEquiJoin::MergeFrom(from.equijoin());
    }
    if (from.has_cross()) {
      mutable_cross()->::LogicalCross::MergeFrom(from.cross());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogicalRaOperator::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicalRaOperator::CopyFrom(const LogicalRaOperator& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalRaOperator::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_scan()) {
    if (!this->scan().IsInitialized()) return false;
  }
  if (has_select()) {
    if (!this->select().IsInitialized()) return false;
  }
  if (has_project()) {
    if (!this->project().IsInitialized()) return false;
  }
  if (has_equijoin()) {
    if (!this->equijoin().IsInitialized()) return false;
  }
  if (has_cross()) {
    if (!this->cross().IsInitialized()) return false;
  }
  return true;
}

void LogicalRaOperator::Swap(LogicalRaOperator* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(name_, other->name_);
    std::swap(scan_, other->scan_);
    std::swap(select_, other->select_);
    std::swap(project_, other->project_);
    std::swap(equijoin_, other->equijoin_);
    std::swap(cross_, other->cross_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogicalRaOperator::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogicalRaOperator_descriptor_;
  metadata.reflection = LogicalRaOperator_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogicalScan::kRelationFieldNumber;
#endif  // !_MSC_VER

LogicalScan::LogicalScan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LogicalScan::InitAsDefaultInstance() {
}

LogicalScan::LogicalScan(const LogicalScan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LogicalScan::SharedCtor() {
  _cached_size_ = 0;
  relation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogicalScan::~LogicalScan() {
  SharedDtor();
}

void LogicalScan::SharedDtor() {
  if (relation_ != &::google::protobuf::internal::kEmptyString) {
    delete relation_;
  }
  if (this != default_instance_) {
  }
}

void LogicalScan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogicalScan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogicalScan_descriptor_;
}

const LogicalScan& LogicalScan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logical_5fra_2eproto();  return *default_instance_;
}

LogicalScan* LogicalScan::default_instance_ = NULL;

LogicalScan* LogicalScan::New() const {
  return new LogicalScan;
}

void LogicalScan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_relation()) {
      if (relation_ != &::google::protobuf::internal::kEmptyString) {
        relation_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogicalScan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string relation = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_relation()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->relation().data(), this->relation().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogicalScan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string relation = 1;
  if (has_relation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->relation().data(), this->relation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->relation(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LogicalScan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string relation = 1;
  if (has_relation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->relation().data(), this->relation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->relation(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LogicalScan::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string relation = 1;
    if (has_relation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->relation());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogicalScan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogicalScan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogicalScan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogicalScan::MergeFrom(const LogicalScan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_relation()) {
      set_relation(from.relation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogicalScan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicalScan::CopyFrom(const LogicalScan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalScan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void LogicalScan::Swap(LogicalScan* other) {
  if (other != this) {
    std::swap(relation_, other->relation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogicalScan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogicalScan_descriptor_;
  metadata.reflection = LogicalScan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogicalSelect::kChildNameFieldNumber;
const int LogicalSelect::kConditionFieldNumber;
#endif  // !_MSC_VER

LogicalSelect::LogicalSelect()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LogicalSelect::InitAsDefaultInstance() {
}

LogicalSelect::LogicalSelect(const LogicalSelect& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LogicalSelect::SharedCtor() {
  _cached_size_ = 0;
  childname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogicalSelect::~LogicalSelect() {
  SharedDtor();
}

void LogicalSelect::SharedDtor() {
  if (childname_ != &::google::protobuf::internal::kEmptyString) {
    delete childname_;
  }
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    delete condition_;
  }
  if (this != default_instance_) {
  }
}

void LogicalSelect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogicalSelect::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogicalSelect_descriptor_;
}

const LogicalSelect& LogicalSelect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logical_5fra_2eproto();  return *default_instance_;
}

LogicalSelect* LogicalSelect::default_instance_ = NULL;

LogicalSelect* LogicalSelect::New() const {
  return new LogicalSelect;
}

void LogicalSelect::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_childname()) {
      if (childname_ != &::google::protobuf::internal::kEmptyString) {
        childname_->clear();
      }
    }
    if (has_condition()) {
      if (condition_ != &::google::protobuf::internal::kEmptyString) {
        condition_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogicalSelect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string childName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_childname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->childname().data(), this->childname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_condition;
        break;
      }
      
      // required string condition = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_condition:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_condition()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->condition().data(), this->condition().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogicalSelect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string childName = 1;
  if (has_childname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->childname().data(), this->childname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->childname(), output);
  }
  
  // required string condition = 2;
  if (has_condition()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->condition().data(), this->condition().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->condition(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LogicalSelect::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string childName = 1;
  if (has_childname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->childname().data(), this->childname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->childname(), target);
  }
  
  // required string condition = 2;
  if (has_condition()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->condition().data(), this->condition().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->condition(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LogicalSelect::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string childName = 1;
    if (has_childname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->childname());
    }
    
    // required string condition = 2;
    if (has_condition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->condition());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogicalSelect::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogicalSelect* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogicalSelect*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogicalSelect::MergeFrom(const LogicalSelect& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_childname()) {
      set_childname(from.childname());
    }
    if (from.has_condition()) {
      set_condition(from.condition());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogicalSelect::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicalSelect::CopyFrom(const LogicalSelect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalSelect::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void LogicalSelect::Swap(LogicalSelect* other) {
  if (other != this) {
    std::swap(childname_, other->childname_);
    std::swap(condition_, other->condition_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogicalSelect::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogicalSelect_descriptor_;
  metadata.reflection = LogicalSelect_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogicalProject::kChildNameFieldNumber;
const int LogicalProject::kColumnsFieldNumber;
#endif  // !_MSC_VER

LogicalProject::LogicalProject()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LogicalProject::InitAsDefaultInstance() {
}

LogicalProject::LogicalProject(const LogicalProject& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LogicalProject::SharedCtor() {
  _cached_size_ = 0;
  childname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogicalProject::~LogicalProject() {
  SharedDtor();
}

void LogicalProject::SharedDtor() {
  if (childname_ != &::google::protobuf::internal::kEmptyString) {
    delete childname_;
  }
  if (this != default_instance_) {
  }
}

void LogicalProject::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogicalProject::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogicalProject_descriptor_;
}

const LogicalProject& LogicalProject::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logical_5fra_2eproto();  return *default_instance_;
}

LogicalProject* LogicalProject::default_instance_ = NULL;

LogicalProject* LogicalProject::New() const {
  return new LogicalProject;
}

void LogicalProject::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_childname()) {
      if (childname_ != &::google::protobuf::internal::kEmptyString) {
        childname_->clear();
      }
    }
  }
  columns_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogicalProject::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string childName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_childname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->childname().data(), this->childname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_columns;
        break;
      }
      
      // repeated int32 columns = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_columns:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_columns())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_columns())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_columns;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogicalProject::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string childName = 1;
  if (has_childname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->childname().data(), this->childname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->childname(), output);
  }
  
  // repeated int32 columns = 2;
  for (int i = 0; i < this->columns_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->columns(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LogicalProject::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string childName = 1;
  if (has_childname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->childname().data(), this->childname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->childname(), target);
  }
  
  // repeated int32 columns = 2;
  for (int i = 0; i < this->columns_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(2, this->columns(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LogicalProject::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string childName = 1;
    if (has_childname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->childname());
    }
    
  }
  // repeated int32 columns = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->columns_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->columns(i));
    }
    total_size += 1 * this->columns_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogicalProject::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogicalProject* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogicalProject*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogicalProject::MergeFrom(const LogicalProject& from) {
  GOOGLE_CHECK_NE(&from, this);
  columns_.MergeFrom(from.columns_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_childname()) {
      set_childname(from.childname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogicalProject::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicalProject::CopyFrom(const LogicalProject& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalProject::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void LogicalProject::Swap(LogicalProject* other) {
  if (other != this) {
    std::swap(childname_, other->childname_);
    columns_.Swap(&other->columns_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogicalProject::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogicalProject_descriptor_;
  metadata.reflection = LogicalProject_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogicalEquiJoin::kLeftChildNameFieldNumber;
const int LogicalEquiJoin::kLeftColumnsFieldNumber;
const int LogicalEquiJoin::kRightChildNameFieldNumber;
const int LogicalEquiJoin::kRightColumnsFieldNumber;
#endif  // !_MSC_VER

LogicalEquiJoin::LogicalEquiJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LogicalEquiJoin::InitAsDefaultInstance() {
}

LogicalEquiJoin::LogicalEquiJoin(const LogicalEquiJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LogicalEquiJoin::SharedCtor() {
  _cached_size_ = 0;
  leftchildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  rightchildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogicalEquiJoin::~LogicalEquiJoin() {
  SharedDtor();
}

void LogicalEquiJoin::SharedDtor() {
  if (leftchildname_ != &::google::protobuf::internal::kEmptyString) {
    delete leftchildname_;
  }
  if (rightchildname_ != &::google::protobuf::internal::kEmptyString) {
    delete rightchildname_;
  }
  if (this != default_instance_) {
  }
}

void LogicalEquiJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogicalEquiJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogicalEquiJoin_descriptor_;
}

const LogicalEquiJoin& LogicalEquiJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logical_5fra_2eproto();  return *default_instance_;
}

LogicalEquiJoin* LogicalEquiJoin::default_instance_ = NULL;

LogicalEquiJoin* LogicalEquiJoin::New() const {
  return new LogicalEquiJoin;
}

void LogicalEquiJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_leftchildname()) {
      if (leftchildname_ != &::google::protobuf::internal::kEmptyString) {
        leftchildname_->clear();
      }
    }
    if (has_rightchildname()) {
      if (rightchildname_ != &::google::protobuf::internal::kEmptyString) {
        rightchildname_->clear();
      }
    }
  }
  leftcolumns_.Clear();
  rightcolumns_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogicalEquiJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string leftChildName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_leftchildname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->leftchildname().data(), this->leftchildname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_leftColumns;
        break;
      }
      
      // repeated int32 leftColumns = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_leftColumns:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_leftcolumns())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_leftcolumns())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_leftColumns;
        if (input->ExpectTag(26)) goto parse_rightChildName;
        break;
      }
      
      // required string rightChildName = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rightChildName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_rightchildname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->rightchildname().data(), this->rightchildname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_rightColumns;
        break;
      }
      
      // repeated int32 rightColumns = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rightColumns:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32, input, this->mutable_rightcolumns())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_rightcolumns())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_rightColumns;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogicalEquiJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string leftChildName = 1;
  if (has_leftchildname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->leftchildname().data(), this->leftchildname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->leftchildname(), output);
  }
  
  // repeated int32 leftColumns = 2;
  for (int i = 0; i < this->leftcolumns_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->leftcolumns(i), output);
  }
  
  // required string rightChildName = 3;
  if (has_rightchildname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->rightchildname().data(), this->rightchildname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->rightchildname(), output);
  }
  
  // repeated int32 rightColumns = 4;
  for (int i = 0; i < this->rightcolumns_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->rightcolumns(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LogicalEquiJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string leftChildName = 1;
  if (has_leftchildname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->leftchildname().data(), this->leftchildname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->leftchildname(), target);
  }
  
  // repeated int32 leftColumns = 2;
  for (int i = 0; i < this->leftcolumns_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(2, this->leftcolumns(i), target);
  }
  
  // required string rightChildName = 3;
  if (has_rightchildname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->rightchildname().data(), this->rightchildname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->rightchildname(), target);
  }
  
  // repeated int32 rightColumns = 4;
  for (int i = 0; i < this->rightcolumns_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(4, this->rightcolumns(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LogicalEquiJoin::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string leftChildName = 1;
    if (has_leftchildname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->leftchildname());
    }
    
    // required string rightChildName = 3;
    if (has_rightchildname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->rightchildname());
    }
    
  }
  // repeated int32 leftColumns = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->leftcolumns_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->leftcolumns(i));
    }
    total_size += 1 * this->leftcolumns_size() + data_size;
  }
  
  // repeated int32 rightColumns = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->rightcolumns_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->rightcolumns(i));
    }
    total_size += 1 * this->rightcolumns_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogicalEquiJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogicalEquiJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogicalEquiJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogicalEquiJoin::MergeFrom(const LogicalEquiJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  leftcolumns_.MergeFrom(from.leftcolumns_);
  rightcolumns_.MergeFrom(from.rightcolumns_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_leftchildname()) {
      set_leftchildname(from.leftchildname());
    }
    if (from.has_rightchildname()) {
      set_rightchildname(from.rightchildname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogicalEquiJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicalEquiJoin::CopyFrom(const LogicalEquiJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalEquiJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  
  return true;
}

void LogicalEquiJoin::Swap(LogicalEquiJoin* other) {
  if (other != this) {
    std::swap(leftchildname_, other->leftchildname_);
    leftcolumns_.Swap(&other->leftcolumns_);
    std::swap(rightchildname_, other->rightchildname_);
    rightcolumns_.Swap(&other->rightcolumns_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogicalEquiJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogicalEquiJoin_descriptor_;
  metadata.reflection = LogicalEquiJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogicalCross::kLeftChildNameFieldNumber;
const int LogicalCross::kRightChildNameFieldNumber;
#endif  // !_MSC_VER

LogicalCross::LogicalCross()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LogicalCross::InitAsDefaultInstance() {
}

LogicalCross::LogicalCross(const LogicalCross& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LogicalCross::SharedCtor() {
  _cached_size_ = 0;
  leftchildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  rightchildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogicalCross::~LogicalCross() {
  SharedDtor();
}

void LogicalCross::SharedDtor() {
  if (leftchildname_ != &::google::protobuf::internal::kEmptyString) {
    delete leftchildname_;
  }
  if (rightchildname_ != &::google::protobuf::internal::kEmptyString) {
    delete rightchildname_;
  }
  if (this != default_instance_) {
  }
}

void LogicalCross::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogicalCross::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogicalCross_descriptor_;
}

const LogicalCross& LogicalCross::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logical_5fra_2eproto();  return *default_instance_;
}

LogicalCross* LogicalCross::default_instance_ = NULL;

LogicalCross* LogicalCross::New() const {
  return new LogicalCross;
}

void LogicalCross::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_leftchildname()) {
      if (leftchildname_ != &::google::protobuf::internal::kEmptyString) {
        leftchildname_->clear();
      }
    }
    if (has_rightchildname()) {
      if (rightchildname_ != &::google::protobuf::internal::kEmptyString) {
        rightchildname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogicalCross::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string leftChildName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_leftchildname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->leftchildname().data(), this->leftchildname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_rightChildName;
        break;
      }
      
      // required string rightChildName = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rightChildName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_rightchildname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->rightchildname().data(), this->rightchildname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogicalCross::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string leftChildName = 1;
  if (has_leftchildname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->leftchildname().data(), this->leftchildname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->leftchildname(), output);
  }
  
  // required string rightChildName = 2;
  if (has_rightchildname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->rightchildname().data(), this->rightchildname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->rightchildname(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LogicalCross::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string leftChildName = 1;
  if (has_leftchildname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->leftchildname().data(), this->leftchildname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->leftchildname(), target);
  }
  
  // required string rightChildName = 2;
  if (has_rightchildname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->rightchildname().data(), this->rightchildname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->rightchildname(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LogicalCross::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string leftChildName = 1;
    if (has_leftchildname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->leftchildname());
    }
    
    // required string rightChildName = 2;
    if (has_rightchildname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->rightchildname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogicalCross::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogicalCross* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogicalCross*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogicalCross::MergeFrom(const LogicalCross& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_leftchildname()) {
      set_leftchildname(from.leftchildname());
    }
    if (from.has_rightchildname()) {
      set_rightchildname(from.rightchildname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogicalCross::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicalCross::CopyFrom(const LogicalCross& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalCross::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void LogicalCross::Swap(LogicalCross* other) {
  if (other != this) {
    std::swap(leftchildname_, other->leftchildname_);
    std::swap(rightchildname_, other->rightchildname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogicalCross::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogicalCross_descriptor_;
  metadata.reflection = LogicalCross_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
