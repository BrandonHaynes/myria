// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: logical_ra.proto

#ifndef PROTOBUF_logical_5fra_2eproto__INCLUDED
#define PROTOBUF_logical_5fra_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_logical_5fra_2eproto();
void protobuf_AssignDesc_logical_5fra_2eproto();
void protobuf_ShutdownFile_logical_5fra_2eproto();

class LogicalRaQueryMessage;
class LogicalRaOperator;
class LogicalScan;
class LogicalSelect;
class LogicalProject;
class LogicalJoin;

enum LogicalRaOperator_LogicalRaOperatorType {
  LogicalRaOperator_LogicalRaOperatorType_SCAN = 0,
  LogicalRaOperator_LogicalRaOperatorType_PROJECT = 1,
  LogicalRaOperator_LogicalRaOperatorType_JOIN = 2
};
bool LogicalRaOperator_LogicalRaOperatorType_IsValid(int value);
const LogicalRaOperator_LogicalRaOperatorType LogicalRaOperator_LogicalRaOperatorType_LogicalRaOperatorType_MIN = LogicalRaOperator_LogicalRaOperatorType_SCAN;
const LogicalRaOperator_LogicalRaOperatorType LogicalRaOperator_LogicalRaOperatorType_LogicalRaOperatorType_MAX = LogicalRaOperator_LogicalRaOperatorType_JOIN;
const int LogicalRaOperator_LogicalRaOperatorType_LogicalRaOperatorType_ARRAYSIZE = LogicalRaOperator_LogicalRaOperatorType_LogicalRaOperatorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogicalRaOperator_LogicalRaOperatorType_descriptor();
inline const ::std::string& LogicalRaOperator_LogicalRaOperatorType_Name(LogicalRaOperator_LogicalRaOperatorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogicalRaOperator_LogicalRaOperatorType_descriptor(), value);
}
inline bool LogicalRaOperator_LogicalRaOperatorType_Parse(
    const ::std::string& name, LogicalRaOperator_LogicalRaOperatorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogicalRaOperator_LogicalRaOperatorType>(
    LogicalRaOperator_LogicalRaOperatorType_descriptor(), name, value);
}
// ===================================================================

class LogicalRaQueryMessage : public ::google::protobuf::Message {
 public:
  LogicalRaQueryMessage();
  virtual ~LogicalRaQueryMessage();
  
  LogicalRaQueryMessage(const LogicalRaQueryMessage& from);
  
  inline LogicalRaQueryMessage& operator=(const LogicalRaQueryMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalRaQueryMessage& default_instance();
  
  void Swap(LogicalRaQueryMessage* other);
  
  // implements Message ----------------------------------------------
  
  LogicalRaQueryMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicalRaQueryMessage& from);
  void MergeFrom(const LogicalRaQueryMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .LogicalRaOperator operator = 3;
  inline int operator__size() const;
  inline void clear_operator_();
  static const int kOperatorFieldNumber = 3;
  inline const ::LogicalRaOperator& operator_(int index) const;
  inline ::LogicalRaOperator* mutable_operator_(int index);
  inline ::LogicalRaOperator* add_operator_();
  inline const ::google::protobuf::RepeatedPtrField< ::LogicalRaOperator >&
      operator_() const;
  inline ::google::protobuf::RepeatedPtrField< ::LogicalRaOperator >*
      mutable_operator_();
  
  // @@protoc_insertion_point(class_scope:LogicalRaQueryMessage)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::LogicalRaOperator > operator__;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_logical_5fra_2eproto();
  friend void protobuf_AssignDesc_logical_5fra_2eproto();
  friend void protobuf_ShutdownFile_logical_5fra_2eproto();
  
  void InitAsDefaultInstance();
  static LogicalRaQueryMessage* default_instance_;
};
// -------------------------------------------------------------------

class LogicalRaOperator : public ::google::protobuf::Message {
 public:
  LogicalRaOperator();
  virtual ~LogicalRaOperator();
  
  LogicalRaOperator(const LogicalRaOperator& from);
  
  inline LogicalRaOperator& operator=(const LogicalRaOperator& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalRaOperator& default_instance();
  
  void Swap(LogicalRaOperator* other);
  
  // implements Message ----------------------------------------------
  
  LogicalRaOperator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicalRaOperator& from);
  void MergeFrom(const LogicalRaOperator& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LogicalRaOperator_LogicalRaOperatorType LogicalRaOperatorType;
  static const LogicalRaOperatorType SCAN = LogicalRaOperator_LogicalRaOperatorType_SCAN;
  static const LogicalRaOperatorType PROJECT = LogicalRaOperator_LogicalRaOperatorType_PROJECT;
  static const LogicalRaOperatorType JOIN = LogicalRaOperator_LogicalRaOperatorType_JOIN;
  static inline bool LogicalRaOperatorType_IsValid(int value) {
    return LogicalRaOperator_LogicalRaOperatorType_IsValid(value);
  }
  static const LogicalRaOperatorType LogicalRaOperatorType_MIN =
    LogicalRaOperator_LogicalRaOperatorType_LogicalRaOperatorType_MIN;
  static const LogicalRaOperatorType LogicalRaOperatorType_MAX =
    LogicalRaOperator_LogicalRaOperatorType_LogicalRaOperatorType_MAX;
  static const int LogicalRaOperatorType_ARRAYSIZE =
    LogicalRaOperator_LogicalRaOperatorType_LogicalRaOperatorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LogicalRaOperatorType_descriptor() {
    return LogicalRaOperator_LogicalRaOperatorType_descriptor();
  }
  static inline const ::std::string& LogicalRaOperatorType_Name(LogicalRaOperatorType value) {
    return LogicalRaOperator_LogicalRaOperatorType_Name(value);
  }
  static inline bool LogicalRaOperatorType_Parse(const ::std::string& name,
      LogicalRaOperatorType* value) {
    return LogicalRaOperator_LogicalRaOperatorType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .LogicalRaOperator.LogicalRaOperatorType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::LogicalRaOperator_LogicalRaOperatorType type() const;
  inline void set_type(::LogicalRaOperator_LogicalRaOperatorType value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional .LogicalScan scan = 3;
  inline bool has_scan() const;
  inline void clear_scan();
  static const int kScanFieldNumber = 3;
  inline const ::LogicalScan& scan() const;
  inline ::LogicalScan* mutable_scan();
  inline ::LogicalScan* release_scan();
  
  // optional .LogicalSelect select = 4;
  inline bool has_select() const;
  inline void clear_select();
  static const int kSelectFieldNumber = 4;
  inline const ::LogicalSelect& select() const;
  inline ::LogicalSelect* mutable_select();
  inline ::LogicalSelect* release_select();
  
  // optional .LogicalProject project = 5;
  inline bool has_project() const;
  inline void clear_project();
  static const int kProjectFieldNumber = 5;
  inline const ::LogicalProject& project() const;
  inline ::LogicalProject* mutable_project();
  inline ::LogicalProject* release_project();
  
  // optional .LogicalJoin join = 6;
  inline bool has_join() const;
  inline void clear_join();
  static const int kJoinFieldNumber = 6;
  inline const ::LogicalJoin& join() const;
  inline ::LogicalJoin* mutable_join();
  inline ::LogicalJoin* release_join();
  
  // @@protoc_insertion_point(class_scope:LogicalRaOperator)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_scan();
  inline void clear_has_scan();
  inline void set_has_select();
  inline void clear_has_select();
  inline void set_has_project();
  inline void clear_has_project();
  inline void set_has_join();
  inline void clear_has_join();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::LogicalScan* scan_;
  ::LogicalSelect* select_;
  ::LogicalProject* project_;
  ::LogicalJoin* join_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_logical_5fra_2eproto();
  friend void protobuf_AssignDesc_logical_5fra_2eproto();
  friend void protobuf_ShutdownFile_logical_5fra_2eproto();
  
  void InitAsDefaultInstance();
  static LogicalRaOperator* default_instance_;
};
// -------------------------------------------------------------------

class LogicalScan : public ::google::protobuf::Message {
 public:
  LogicalScan();
  virtual ~LogicalScan();
  
  LogicalScan(const LogicalScan& from);
  
  inline LogicalScan& operator=(const LogicalScan& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalScan& default_instance();
  
  void Swap(LogicalScan* other);
  
  // implements Message ----------------------------------------------
  
  LogicalScan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicalScan& from);
  void MergeFrom(const LogicalScan& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string relation = 1;
  inline bool has_relation() const;
  inline void clear_relation();
  static const int kRelationFieldNumber = 1;
  inline const ::std::string& relation() const;
  inline void set_relation(const ::std::string& value);
  inline void set_relation(const char* value);
  inline void set_relation(const char* value, size_t size);
  inline ::std::string* mutable_relation();
  inline ::std::string* release_relation();
  
  // @@protoc_insertion_point(class_scope:LogicalScan)
 private:
  inline void set_has_relation();
  inline void clear_has_relation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* relation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_logical_5fra_2eproto();
  friend void protobuf_AssignDesc_logical_5fra_2eproto();
  friend void protobuf_ShutdownFile_logical_5fra_2eproto();
  
  void InitAsDefaultInstance();
  static LogicalScan* default_instance_;
};
// -------------------------------------------------------------------

class LogicalSelect : public ::google::protobuf::Message {
 public:
  LogicalSelect();
  virtual ~LogicalSelect();
  
  LogicalSelect(const LogicalSelect& from);
  
  inline LogicalSelect& operator=(const LogicalSelect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalSelect& default_instance();
  
  void Swap(LogicalSelect* other);
  
  // implements Message ----------------------------------------------
  
  LogicalSelect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicalSelect& from);
  void MergeFrom(const LogicalSelect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string childName = 1;
  inline bool has_childname() const;
  inline void clear_childname();
  static const int kChildNameFieldNumber = 1;
  inline const ::std::string& childname() const;
  inline void set_childname(const ::std::string& value);
  inline void set_childname(const char* value);
  inline void set_childname(const char* value, size_t size);
  inline ::std::string* mutable_childname();
  inline ::std::string* release_childname();
  
  // required string condition = 2;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 2;
  inline const ::std::string& condition() const;
  inline void set_condition(const ::std::string& value);
  inline void set_condition(const char* value);
  inline void set_condition(const char* value, size_t size);
  inline ::std::string* mutable_condition();
  inline ::std::string* release_condition();
  
  // @@protoc_insertion_point(class_scope:LogicalSelect)
 private:
  inline void set_has_childname();
  inline void clear_has_childname();
  inline void set_has_condition();
  inline void clear_has_condition();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* childname_;
  ::std::string* condition_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_logical_5fra_2eproto();
  friend void protobuf_AssignDesc_logical_5fra_2eproto();
  friend void protobuf_ShutdownFile_logical_5fra_2eproto();
  
  void InitAsDefaultInstance();
  static LogicalSelect* default_instance_;
};
// -------------------------------------------------------------------

class LogicalProject : public ::google::protobuf::Message {
 public:
  LogicalProject();
  virtual ~LogicalProject();
  
  LogicalProject(const LogicalProject& from);
  
  inline LogicalProject& operator=(const LogicalProject& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalProject& default_instance();
  
  void Swap(LogicalProject* other);
  
  // implements Message ----------------------------------------------
  
  LogicalProject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicalProject& from);
  void MergeFrom(const LogicalProject& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string childName = 1;
  inline bool has_childname() const;
  inline void clear_childname();
  static const int kChildNameFieldNumber = 1;
  inline const ::std::string& childname() const;
  inline void set_childname(const ::std::string& value);
  inline void set_childname(const char* value);
  inline void set_childname(const char* value, size_t size);
  inline ::std::string* mutable_childname();
  inline ::std::string* release_childname();
  
  // repeated int32 column = 2;
  inline int column_size() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 2;
  inline ::google::protobuf::int32 column(int index) const;
  inline void set_column(int index, ::google::protobuf::int32 value);
  inline void add_column(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_column();
  
  // @@protoc_insertion_point(class_scope:LogicalProject)
 private:
  inline void set_has_childname();
  inline void clear_has_childname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* childname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > column_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_logical_5fra_2eproto();
  friend void protobuf_AssignDesc_logical_5fra_2eproto();
  friend void protobuf_ShutdownFile_logical_5fra_2eproto();
  
  void InitAsDefaultInstance();
  static LogicalProject* default_instance_;
};
// -------------------------------------------------------------------

class LogicalJoin : public ::google::protobuf::Message {
 public:
  LogicalJoin();
  virtual ~LogicalJoin();
  
  LogicalJoin(const LogicalJoin& from);
  
  inline LogicalJoin& operator=(const LogicalJoin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalJoin& default_instance();
  
  void Swap(LogicalJoin* other);
  
  // implements Message ----------------------------------------------
  
  LogicalJoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicalJoin& from);
  void MergeFrom(const LogicalJoin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string leftChildName = 1;
  inline bool has_leftchildname() const;
  inline void clear_leftchildname();
  static const int kLeftChildNameFieldNumber = 1;
  inline const ::std::string& leftchildname() const;
  inline void set_leftchildname(const ::std::string& value);
  inline void set_leftchildname(const char* value);
  inline void set_leftchildname(const char* value, size_t size);
  inline ::std::string* mutable_leftchildname();
  inline ::std::string* release_leftchildname();
  
  // repeated int32 leftColumn = 2;
  inline int leftcolumn_size() const;
  inline void clear_leftcolumn();
  static const int kLeftColumnFieldNumber = 2;
  inline ::google::protobuf::int32 leftcolumn(int index) const;
  inline void set_leftcolumn(int index, ::google::protobuf::int32 value);
  inline void add_leftcolumn(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      leftcolumn() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_leftcolumn();
  
  // required string rightChildName = 3;
  inline bool has_rightchildname() const;
  inline void clear_rightchildname();
  static const int kRightChildNameFieldNumber = 3;
  inline const ::std::string& rightchildname() const;
  inline void set_rightchildname(const ::std::string& value);
  inline void set_rightchildname(const char* value);
  inline void set_rightchildname(const char* value, size_t size);
  inline ::std::string* mutable_rightchildname();
  inline ::std::string* release_rightchildname();
  
  // repeated int32 rightColumn = 4;
  inline int rightcolumn_size() const;
  inline void clear_rightcolumn();
  static const int kRightColumnFieldNumber = 4;
  inline ::google::protobuf::int32 rightcolumn(int index) const;
  inline void set_rightcolumn(int index, ::google::protobuf::int32 value);
  inline void add_rightcolumn(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      rightcolumn() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_rightcolumn();
  
  // @@protoc_insertion_point(class_scope:LogicalJoin)
 private:
  inline void set_has_leftchildname();
  inline void clear_has_leftchildname();
  inline void set_has_rightchildname();
  inline void clear_has_rightchildname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* leftchildname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > leftcolumn_;
  ::std::string* rightchildname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > rightcolumn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_logical_5fra_2eproto();
  friend void protobuf_AssignDesc_logical_5fra_2eproto();
  friend void protobuf_ShutdownFile_logical_5fra_2eproto();
  
  void InitAsDefaultInstance();
  static LogicalJoin* default_instance_;
};
// ===================================================================


// ===================================================================

// LogicalRaQueryMessage

// required string name = 1;
inline bool LogicalRaQueryMessage::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicalRaQueryMessage::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicalRaQueryMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicalRaQueryMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LogicalRaQueryMessage::name() const {
  return *name_;
}
inline void LogicalRaQueryMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LogicalRaQueryMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LogicalRaQueryMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalRaQueryMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LogicalRaQueryMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .LogicalRaOperator operator = 3;
inline int LogicalRaQueryMessage::operator__size() const {
  return operator__.size();
}
inline void LogicalRaQueryMessage::clear_operator_() {
  operator__.Clear();
}
inline const ::LogicalRaOperator& LogicalRaQueryMessage::operator_(int index) const {
  return operator__.Get(index);
}
inline ::LogicalRaOperator* LogicalRaQueryMessage::mutable_operator_(int index) {
  return operator__.Mutable(index);
}
inline ::LogicalRaOperator* LogicalRaQueryMessage::add_operator_() {
  return operator__.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LogicalRaOperator >&
LogicalRaQueryMessage::operator_() const {
  return operator__;
}
inline ::google::protobuf::RepeatedPtrField< ::LogicalRaOperator >*
LogicalRaQueryMessage::mutable_operator_() {
  return &operator__;
}

// -------------------------------------------------------------------

// LogicalRaOperator

// required .LogicalRaOperator.LogicalRaOperatorType type = 1;
inline bool LogicalRaOperator::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicalRaOperator::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicalRaOperator::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicalRaOperator::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::LogicalRaOperator_LogicalRaOperatorType LogicalRaOperator::type() const {
  return static_cast< ::LogicalRaOperator_LogicalRaOperatorType >(type_);
}
inline void LogicalRaOperator::set_type(::LogicalRaOperator_LogicalRaOperatorType value) {
  GOOGLE_DCHECK(::LogicalRaOperator_LogicalRaOperatorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string name = 2;
inline bool LogicalRaOperator::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicalRaOperator::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicalRaOperator::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicalRaOperator::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LogicalRaOperator::name() const {
  return *name_;
}
inline void LogicalRaOperator::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LogicalRaOperator::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LogicalRaOperator::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalRaOperator::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LogicalRaOperator::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .LogicalScan scan = 3;
inline bool LogicalRaOperator::has_scan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogicalRaOperator::set_has_scan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogicalRaOperator::clear_has_scan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogicalRaOperator::clear_scan() {
  if (scan_ != NULL) scan_->::LogicalScan::Clear();
  clear_has_scan();
}
inline const ::LogicalScan& LogicalRaOperator::scan() const {
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
inline ::LogicalScan* LogicalRaOperator::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) scan_ = new ::LogicalScan;
  return scan_;
}
inline ::LogicalScan* LogicalRaOperator::release_scan() {
  clear_has_scan();
  ::LogicalScan* temp = scan_;
  scan_ = NULL;
  return temp;
}

// optional .LogicalSelect select = 4;
inline bool LogicalRaOperator::has_select() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogicalRaOperator::set_has_select() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogicalRaOperator::clear_has_select() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogicalRaOperator::clear_select() {
  if (select_ != NULL) select_->::LogicalSelect::Clear();
  clear_has_select();
}
inline const ::LogicalSelect& LogicalRaOperator::select() const {
  return select_ != NULL ? *select_ : *default_instance_->select_;
}
inline ::LogicalSelect* LogicalRaOperator::mutable_select() {
  set_has_select();
  if (select_ == NULL) select_ = new ::LogicalSelect;
  return select_;
}
inline ::LogicalSelect* LogicalRaOperator::release_select() {
  clear_has_select();
  ::LogicalSelect* temp = select_;
  select_ = NULL;
  return temp;
}

// optional .LogicalProject project = 5;
inline bool LogicalRaOperator::has_project() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogicalRaOperator::set_has_project() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogicalRaOperator::clear_has_project() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogicalRaOperator::clear_project() {
  if (project_ != NULL) project_->::LogicalProject::Clear();
  clear_has_project();
}
inline const ::LogicalProject& LogicalRaOperator::project() const {
  return project_ != NULL ? *project_ : *default_instance_->project_;
}
inline ::LogicalProject* LogicalRaOperator::mutable_project() {
  set_has_project();
  if (project_ == NULL) project_ = new ::LogicalProject;
  return project_;
}
inline ::LogicalProject* LogicalRaOperator::release_project() {
  clear_has_project();
  ::LogicalProject* temp = project_;
  project_ = NULL;
  return temp;
}

// optional .LogicalJoin join = 6;
inline bool LogicalRaOperator::has_join() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogicalRaOperator::set_has_join() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogicalRaOperator::clear_has_join() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogicalRaOperator::clear_join() {
  if (join_ != NULL) join_->::LogicalJoin::Clear();
  clear_has_join();
}
inline const ::LogicalJoin& LogicalRaOperator::join() const {
  return join_ != NULL ? *join_ : *default_instance_->join_;
}
inline ::LogicalJoin* LogicalRaOperator::mutable_join() {
  set_has_join();
  if (join_ == NULL) join_ = new ::LogicalJoin;
  return join_;
}
inline ::LogicalJoin* LogicalRaOperator::release_join() {
  clear_has_join();
  ::LogicalJoin* temp = join_;
  join_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// LogicalScan

// required string relation = 1;
inline bool LogicalScan::has_relation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicalScan::set_has_relation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicalScan::clear_has_relation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicalScan::clear_relation() {
  if (relation_ != &::google::protobuf::internal::kEmptyString) {
    relation_->clear();
  }
  clear_has_relation();
}
inline const ::std::string& LogicalScan::relation() const {
  return *relation_;
}
inline void LogicalScan::set_relation(const ::std::string& value) {
  set_has_relation();
  if (relation_ == &::google::protobuf::internal::kEmptyString) {
    relation_ = new ::std::string;
  }
  relation_->assign(value);
}
inline void LogicalScan::set_relation(const char* value) {
  set_has_relation();
  if (relation_ == &::google::protobuf::internal::kEmptyString) {
    relation_ = new ::std::string;
  }
  relation_->assign(value);
}
inline void LogicalScan::set_relation(const char* value, size_t size) {
  set_has_relation();
  if (relation_ == &::google::protobuf::internal::kEmptyString) {
    relation_ = new ::std::string;
  }
  relation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalScan::mutable_relation() {
  set_has_relation();
  if (relation_ == &::google::protobuf::internal::kEmptyString) {
    relation_ = new ::std::string;
  }
  return relation_;
}
inline ::std::string* LogicalScan::release_relation() {
  clear_has_relation();
  if (relation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = relation_;
    relation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LogicalSelect

// required string childName = 1;
inline bool LogicalSelect::has_childname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicalSelect::set_has_childname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicalSelect::clear_has_childname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicalSelect::clear_childname() {
  if (childname_ != &::google::protobuf::internal::kEmptyString) {
    childname_->clear();
  }
  clear_has_childname();
}
inline const ::std::string& LogicalSelect::childname() const {
  return *childname_;
}
inline void LogicalSelect::set_childname(const ::std::string& value) {
  set_has_childname();
  if (childname_ == &::google::protobuf::internal::kEmptyString) {
    childname_ = new ::std::string;
  }
  childname_->assign(value);
}
inline void LogicalSelect::set_childname(const char* value) {
  set_has_childname();
  if (childname_ == &::google::protobuf::internal::kEmptyString) {
    childname_ = new ::std::string;
  }
  childname_->assign(value);
}
inline void LogicalSelect::set_childname(const char* value, size_t size) {
  set_has_childname();
  if (childname_ == &::google::protobuf::internal::kEmptyString) {
    childname_ = new ::std::string;
  }
  childname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalSelect::mutable_childname() {
  set_has_childname();
  if (childname_ == &::google::protobuf::internal::kEmptyString) {
    childname_ = new ::std::string;
  }
  return childname_;
}
inline ::std::string* LogicalSelect::release_childname() {
  clear_has_childname();
  if (childname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = childname_;
    childname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string condition = 2;
inline bool LogicalSelect::has_condition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicalSelect::set_has_condition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicalSelect::clear_has_condition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicalSelect::clear_condition() {
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    condition_->clear();
  }
  clear_has_condition();
}
inline const ::std::string& LogicalSelect::condition() const {
  return *condition_;
}
inline void LogicalSelect::set_condition(const ::std::string& value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void LogicalSelect::set_condition(const char* value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void LogicalSelect::set_condition(const char* value, size_t size) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalSelect::mutable_condition() {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  return condition_;
}
inline ::std::string* LogicalSelect::release_condition() {
  clear_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = condition_;
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LogicalProject

// required string childName = 1;
inline bool LogicalProject::has_childname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicalProject::set_has_childname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicalProject::clear_has_childname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicalProject::clear_childname() {
  if (childname_ != &::google::protobuf::internal::kEmptyString) {
    childname_->clear();
  }
  clear_has_childname();
}
inline const ::std::string& LogicalProject::childname() const {
  return *childname_;
}
inline void LogicalProject::set_childname(const ::std::string& value) {
  set_has_childname();
  if (childname_ == &::google::protobuf::internal::kEmptyString) {
    childname_ = new ::std::string;
  }
  childname_->assign(value);
}
inline void LogicalProject::set_childname(const char* value) {
  set_has_childname();
  if (childname_ == &::google::protobuf::internal::kEmptyString) {
    childname_ = new ::std::string;
  }
  childname_->assign(value);
}
inline void LogicalProject::set_childname(const char* value, size_t size) {
  set_has_childname();
  if (childname_ == &::google::protobuf::internal::kEmptyString) {
    childname_ = new ::std::string;
  }
  childname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalProject::mutable_childname() {
  set_has_childname();
  if (childname_ == &::google::protobuf::internal::kEmptyString) {
    childname_ = new ::std::string;
  }
  return childname_;
}
inline ::std::string* LogicalProject::release_childname() {
  clear_has_childname();
  if (childname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = childname_;
    childname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 column = 2;
inline int LogicalProject::column_size() const {
  return column_.size();
}
inline void LogicalProject::clear_column() {
  column_.Clear();
}
inline ::google::protobuf::int32 LogicalProject::column(int index) const {
  return column_.Get(index);
}
inline void LogicalProject::set_column(int index, ::google::protobuf::int32 value) {
  column_.Set(index, value);
}
inline void LogicalProject::add_column(::google::protobuf::int32 value) {
  column_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LogicalProject::column() const {
  return column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LogicalProject::mutable_column() {
  return &column_;
}

// -------------------------------------------------------------------

// LogicalJoin

// required string leftChildName = 1;
inline bool LogicalJoin::has_leftchildname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicalJoin::set_has_leftchildname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicalJoin::clear_has_leftchildname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicalJoin::clear_leftchildname() {
  if (leftchildname_ != &::google::protobuf::internal::kEmptyString) {
    leftchildname_->clear();
  }
  clear_has_leftchildname();
}
inline const ::std::string& LogicalJoin::leftchildname() const {
  return *leftchildname_;
}
inline void LogicalJoin::set_leftchildname(const ::std::string& value) {
  set_has_leftchildname();
  if (leftchildname_ == &::google::protobuf::internal::kEmptyString) {
    leftchildname_ = new ::std::string;
  }
  leftchildname_->assign(value);
}
inline void LogicalJoin::set_leftchildname(const char* value) {
  set_has_leftchildname();
  if (leftchildname_ == &::google::protobuf::internal::kEmptyString) {
    leftchildname_ = new ::std::string;
  }
  leftchildname_->assign(value);
}
inline void LogicalJoin::set_leftchildname(const char* value, size_t size) {
  set_has_leftchildname();
  if (leftchildname_ == &::google::protobuf::internal::kEmptyString) {
    leftchildname_ = new ::std::string;
  }
  leftchildname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalJoin::mutable_leftchildname() {
  set_has_leftchildname();
  if (leftchildname_ == &::google::protobuf::internal::kEmptyString) {
    leftchildname_ = new ::std::string;
  }
  return leftchildname_;
}
inline ::std::string* LogicalJoin::release_leftchildname() {
  clear_has_leftchildname();
  if (leftchildname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leftchildname_;
    leftchildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 leftColumn = 2;
inline int LogicalJoin::leftcolumn_size() const {
  return leftcolumn_.size();
}
inline void LogicalJoin::clear_leftcolumn() {
  leftcolumn_.Clear();
}
inline ::google::protobuf::int32 LogicalJoin::leftcolumn(int index) const {
  return leftcolumn_.Get(index);
}
inline void LogicalJoin::set_leftcolumn(int index, ::google::protobuf::int32 value) {
  leftcolumn_.Set(index, value);
}
inline void LogicalJoin::add_leftcolumn(::google::protobuf::int32 value) {
  leftcolumn_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LogicalJoin::leftcolumn() const {
  return leftcolumn_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LogicalJoin::mutable_leftcolumn() {
  return &leftcolumn_;
}

// required string rightChildName = 3;
inline bool LogicalJoin::has_rightchildname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogicalJoin::set_has_rightchildname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogicalJoin::clear_has_rightchildname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogicalJoin::clear_rightchildname() {
  if (rightchildname_ != &::google::protobuf::internal::kEmptyString) {
    rightchildname_->clear();
  }
  clear_has_rightchildname();
}
inline const ::std::string& LogicalJoin::rightchildname() const {
  return *rightchildname_;
}
inline void LogicalJoin::set_rightchildname(const ::std::string& value) {
  set_has_rightchildname();
  if (rightchildname_ == &::google::protobuf::internal::kEmptyString) {
    rightchildname_ = new ::std::string;
  }
  rightchildname_->assign(value);
}
inline void LogicalJoin::set_rightchildname(const char* value) {
  set_has_rightchildname();
  if (rightchildname_ == &::google::protobuf::internal::kEmptyString) {
    rightchildname_ = new ::std::string;
  }
  rightchildname_->assign(value);
}
inline void LogicalJoin::set_rightchildname(const char* value, size_t size) {
  set_has_rightchildname();
  if (rightchildname_ == &::google::protobuf::internal::kEmptyString) {
    rightchildname_ = new ::std::string;
  }
  rightchildname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalJoin::mutable_rightchildname() {
  set_has_rightchildname();
  if (rightchildname_ == &::google::protobuf::internal::kEmptyString) {
    rightchildname_ = new ::std::string;
  }
  return rightchildname_;
}
inline ::std::string* LogicalJoin::release_rightchildname() {
  clear_has_rightchildname();
  if (rightchildname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rightchildname_;
    rightchildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 rightColumn = 4;
inline int LogicalJoin::rightcolumn_size() const {
  return rightcolumn_.size();
}
inline void LogicalJoin::clear_rightcolumn() {
  rightcolumn_.Clear();
}
inline ::google::protobuf::int32 LogicalJoin::rightcolumn(int index) const {
  return rightcolumn_.Get(index);
}
inline void LogicalJoin::set_rightcolumn(int index, ::google::protobuf::int32 value) {
  rightcolumn_.Set(index, value);
}
inline void LogicalJoin::add_rightcolumn(::google::protobuf::int32 value) {
  rightcolumn_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LogicalJoin::rightcolumn() const {
  return rightcolumn_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LogicalJoin::mutable_rightcolumn() {
  return &rightcolumn_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LogicalRaOperator_LogicalRaOperatorType>() {
  return ::LogicalRaOperator_LogicalRaOperatorType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_logical_5fra_2eproto__INCLUDED
